class Solution {
    class UF {
        int[] parent;
        public UF(int N) {
            parent = new int[N];
            
            for (int i = 0; i < N; i++) {
                parent[i] = i;
            }
        }
        
        public void union (int x, int y) {
            x = find(x);
            y = find(y);
            if (x < y) {
                parent[y] = x;
            } else {
                parent[x] = y;
            }
        }
        
        public int find(int x) {
            if (x != parent[x]) {
                parent[x] = find(parent[x]);
            }
            return parent[x]; 
        }
    }
    public int minMalwareSpread(int[][] graph, int[] initial) {
        int N = graph.length;
        UF uf = new UF(N);
        
        for (int i = 0; i < N ;i++) {
            for (int j = i+1; j < N; j++) {
                if (graph[i][j] == 1) uf.union(i, j);
            }
        }
        
        Map<Integer, Integer> count = new HashMap<>();
        for (int i = 0; i < N ;i++) {
            int parent = uf.find(i);
            count.put(parent, count.getOrDefault(parent, 0) + 1);
        }
        
        Map<Integer, Set<Integer>> group = new HashMap<>();
        int minNode = Integer.MAX_VALUE;
        for (int i = 0; i < initial.length; i++) {
            minNode = Math.min(minNode, initial[i]);
            int root = uf.find(initial[i]);
            group.computeIfAbsent(root, k -> new HashSet<>()).add(initial[i]);
        }
        
        // caculate remove node
        int node = Integer.MAX_VALUE;
        boolean hasOne = false;
        int curCount = 0;
        for (int key : group.keySet()) {
            Set<Integer> set = group.get(key);
            hasOne = set.size() == 1;
            if (hasOne && set.size() == 1) {
                if (count.get(key) > curCount) {
                    curCount = count.get(key);
                    for (int cur : set) {
                        node = cur;
                    }
                }
                
            }
        }
        return hasOne ? node : minNode;
    }
}

/*class Solution {
    int[] ids;
    int[] size;
    public int minMalwareSpread(int[][] graph, int[] initial) {
        int N = graph.length;
        ids = new int[N];;
        for(int i = 0; i < N; i ++){
            ids[i] = i;
        } 
        size = new int[N];
        Arrays.fill(size, 1);
        Arrays.sort(initial);
        for(int i = 0; i < N; i ++){
            for(int j = i + 1; j < N; j ++){
                if(graph[i][j] == 1){
                    union(i, j);
                } 
            }
        }
        //key- id  val-count
        Map<Integer, Integer> map = new HashMap<>();
        for(int n : initial){
            int idn = find(n);
            map.put(idn, map.getOrDefault(idn, 0) + 1);
        }
        
        int cur_node = initial[0];
        int cur_size = Integer.MIN_VALUE;
        for(int node : initial){
            int idnode = find(node);
            if(map.get(idnode) == 1 && size[idnode] > cur_size){
                cur_node = node;
                cur_size = size[idnode];
            }
        }
        return cur_node;
    }
    
    
    public int find(int p){
        while(p != ids[p]){
            ids[p] = ids[ids[p]];
            p = ids[p];
        }
        return p;
    }
    
    public void union(int i, int j){
        int idi = find(i);
        int idj = find(j);
        if(idi != idj){
            ids[idi] = idj;
            size[idj] += size[idi];
        }
    }
}*/
