### 301.Remove-Invalid-Parentheses

本题没有太高明的办法，基本就是靠搜索，数量级应该就是O(2^N).DFS和BFS均可。感觉对于在同一个数组或字符串里面搜若干个元素的话，DFS写起来更舒服一些。基本思想就是对于每一个s[i]都有“选用”（append到当前curStr中去）和“不选用”两种选择，然后依次递归下去。如果遇到curStr不合法的情况，就及时中断这条支路。

但本题最大的考点应该在于如何避免最后大量重复的结果。比如说我们想在“((()”里面最终得到"()"，其实就有好几种DFS的路径。比如说"XXOO", "XOXO", "OXXO".可见原字符串中的三个“(((”，可以有三种不同的路径得到最后只剩一个"("。如果无脑地对每个字符都尝试“选用”和“不选用”，那么最后势必要依靠字符串类型的集合来去重，效率会很低。

本题的精彩之处，是在于设计一种DFS路径选择机制，能够避开任何可能造成重复的路径。规则如下：
1. 任何情况下，都允许“选用”当前的字符s[i]，即```curStr.append(s[i])```
2. 仅当```curStr.size()==0 || s[i]==curStr.back()```时，不允许“不选用”s[i]，即只可以用第一种方案。Otherwise，允许“不选用”s[i]，即保持当前的curStr。

本题的精彩之处，是在于设计一种DFS路径选择机制，能够避开任何可能造成重复的路径。规则如下：
1. 如果备选字符s[i]与已选字符串的最后一位相同，那么你必须选择使用这个字符，即```curStr.append(s[i])```
2. 如果备选字符s[i]与已选字符串的最后一位不相同，那么你可以选择使用这个字符，也可以选择不使用，接下来的两条分叉递归处理。

这个规则的言下之意是，如果最终生成的字符串含有若干个相同的字符，那么这些相同字符在s中的位置也必须是连续的（当然中间允许穿插若干其他的字符）。举个例子，如果s中有四个连续的左括号（忽略中间任何非左括号的字符），最终它们只保留下来两个左括号，那么一定是```XXOO```的形式，而不能是```OOXX,OXOX,OXXO,XOOX,XOXO```这五种形式。这样就避免了六种DFS搜索形式对应同一个最终结果的复杂局面。


[Leetcode Link](https://leetcode.com/problems/remove-invalid-parentheses)
