### 996.Number-of-Squareful-Arrays

这是常见的深度搜索题，和473，698都很相似。这类题目都需要用visited（通常是一个bool数组或者整形集合）来记录已经访问过的元素来避免重复。

这类题有个比较常见的剪枝去重的策略，要学会掌握：比如对于数列1,2,2,2,3,4,我们想取不重复的permutation。当我们考察完1,2,X,X,X之后，需要回溯考虑第二个位置元素的选取。我们发现，如果第二个位置再选其他的“2”，就会又完全重复之前的搜索。尽管是两个不同的“2”，但这样的搜索是重复。所以我们一般会将这个位置上的候选数字从小到大排序，如果发现候选数组的idx满足下面的条件时就略过：
```
if (i>=1 && A[i]==A[i-1] && visited.find(i-1)==visited.end()) continue;
```
其中最后那个条件很关键。并不是说所有的2都不选，而是与它平级的2才不选。在上面的例子中，如果我们在第一次考察1,2,?,?,?的时候，第三个位置是可以填写2的。因为之前与它重复的A[1]=2已经被选入答案里面(visited)去了，是它上一个深度层级，不影响。但是我们考察完1,2,2,X,X之后，需要回溯考虑第三个未知元素的选取，这个时候我们不能再选择A[3]=2这个元素了，因为这个位置上我们已经考察过A[2]=2了，并且此时因为回溯这个2已经不在visited里面了。

所以，在本题中为了保证Map[cur]的所有候选元素是顺序的，我们需要预先将A进行排序。

此外，另外一个细节就是如何判断一个数是否是平方数？正确的做法是```if (sqrt(x)==(int)sqrt(x))```


[Leetcode Link](https://leetcode.com/problems/number-of-squareful-arrays)
