### 方法一：BFS + 有序集合

我们记字符串 $s$ 的长度为 $n$，记当前字符串中 '0' 的数量为 $\textit{cur}$，每一次操作，我们选择其中 $k$ 个下标进行翻转，其中有 $x$ 个下标从 '0' 翻转为 '1'，有 $k-x$ 个下标从 '1' 翻转为 '0'，则翻转后字符串中 '0' 的数量为 $\textit{cur} + k - 2x$。

而 $x$ 的取值需要满足以下条件：

1. 最多取 $\min(\textit{cur}, k)$ 个 '0'，因为我们不能翻转超过 $\textit{cur}$ 个 '0'，那么 $0 \leq x \leq \min(\textit{cur}, k)$。
2. 最多取 $n - \textit{cur}$ 个 '1'，因为我们不能翻转超过 $n - \textit{cur}$ 个 '1'，那么 $k - x \leq n - \textit{cur}$，即 $x \geq k - n + \textit{cur}$。

因此 $x$ 的取值范围为 $[\max(k - n + \textit{cur}, 0), \min(\textit{cur}, k)]$，翻转后字符串中 '0' 的数量的取值范围为 $[\textit{cur} + k - 2 \cdot \min(\textit{cur}, k), \textit{cur} + k - 2 \cdot \max(k - n + \textit{cur}, 0)]$。

我们注意到，翻转后字符串中 '0' 的数量的奇偶性与翻转前字符串中 '0' 的数量的奇偶性相同。因此，我们可以使用两个有序集合分别存储 '0' 的数量为偶数和奇数的状态。

我们使用 BFS 来搜索状态转移图，初始状态为字符串中 '0' 的数量，目标状态为 0。每次从队列中取出一个状态 $\textit{cur}$，计算翻转后字符串中 '0' 的数量的取值范围 $[l, r]$，在有序集合中找到所有在 $[l, r]$ 范围内的状态，并将它们加入队列，同时从有序集合中删除它们。

如果我们在 BFS 过程中访问到了状态 0，则返回当前的操作次数；如果 BFS 结束后仍未访问到状态 0，则返回 -1。

时间复杂度 $O(n \log n)$，空间复杂度 $O(n)$。其中 $O(n)$ 是 BFS 过程中可能访问的状态数量，而 $O(\log n)$ 是在有序集合中插入和删除元素的时间复杂度。
